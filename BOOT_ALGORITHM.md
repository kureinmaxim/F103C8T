# Алгоритм загрузки и работы primGPT

Полное описание того, что происходит от подачи питания до работающей системы с тремя задачами FreeRTOS.

---

## Что показал отладчик

При нажатии F5 (Debug) GDB остановился здесь:

```
frame: addr="0x08001278", func="Reset_Handler",
file="../Core/Startup/startup_stm32f103c8tx.s", line="64"
```

Это **самая первая инструкция**, которую выполняет процессор после сброса. Отладчик сделал **halt** до того, как код дошёл до `main()`. Это нормальное поведение.

### Что такое halt

**halt** — команда принудительной остановки процессора. Это как "поставить на паузу": процессор замирает на текущей инструкции, регистры и память застывают. Ни одна инструкция не выполняется, пока отладчик не скажет "продолжай" (`continue` / `step`).

### Что происходит при нажатии F5

| Шаг | Что делает | Результат |
|-----|-----------|-----------|
| 1 | OpenOCD подключается к процессору через ST-Link | Связь установлена |
| 2 | OpenOCD посылает команду **halt** | Процессор останавливается на текущей инструкции (строка 64 `Reset_Handler`) |
| 3 | GDB получает управление | Видит, где именно остановился процессор |
| 4 | GDB выполняет `runToEntryPoint: "main"` | Ставит временный breakpoint на `main()` и даёт команду `continue` |
| 5 | Процессор бежит дальше | Останавливается уже на `main()` |

В данном случае halt попал на `Reset_Handler` строку 64 (`bl SystemInit`) — процессор только начал работу после сброса и ещё не дошёл до C-кода.

### Что такое MSP (Main Stack Pointer)

У Cortex-M3 **два** указателя стека:

| Указатель | Полное имя | Когда используется |
|-----------|------------|-------------------|
| **MSP** | Main Stack Pointer | При сбросе, в прерываниях (ISR), и в обычном коде до запуска FreeRTOS |
| **PSP** | Process Stack Pointer | FreeRTOS переключает каждую задачу на свой PSP |

Как это работает в проекте:

- **До `osKernelStart()`** — процессор использует **MSP** (= `0x20005000`, вершина RAM). Весь `main()`, вся инициализация HAL — на MSP.
- **После `osKernelStart()`** — каждая задача получает **свой PSP**, указывающий на стек из FreeRTOS heap:

| Задача | Стек (PSP) |
|--------|-----------|
| Uart1Task | 2048 байт из heap |
| StartDefaultTask | 1024 байт из heap |
| LedTask | 512 байт из heap |

- **Прерывания** (например `USART1_IRQHandler`) — **всегда** используют MSP, даже когда FreeRTOS работает. Поэтому в linker script зарезервировано 1 KB под MSP (`_Min_Stack_Size = 0x400`) — это стек для всех ISR.

---

## Фаза 0: Аппаратный сброс (до первой инструкции)

```
Питание / Reset кнопка / ST-Link reset
         │
         ▼
┌─────────────────────────────────────────┐
│  Cortex-M3 аппаратная логика:           │
│  1. Читает адрес 0x08000000 → _estack   │
│     (загружает в MSP = 0x20005000)       │
│  2. Читает адрес 0x08000004 → адрес     │
│     Reset_Handler                        │
│  3. Переходит на Reset_Handler           │
└─────────────────────────────────────────┘
```

Процессор **аппаратно** берёт два первых слова из Flash:
- `0x08000000` — начальное значение стека (MSP) → вершина RAM (`0x20005000` = `0x20000000 + 20K`)
- `0x08000004` — адрес `Reset_Handler` → туда прыгает процессор

Эти значения берутся из таблицы векторов прерываний (`g_pfnVectors` в `startup_stm32f103c8tx.s`):

Таблица векторов — это массив адресов в файле `startup_stm32f103c8tx.s:129-198`.
Вот она (упрощённо):

| Адрес Flash | Смещение | Что лежит |
|-------------|----------|-----------|
| 0x08000000 | 0x000 | `_estack` (начальный SP = 0x20005000) |
| 0x08000004 | 0x004 | `Reset_Handler` — сюда прыгает CPU после сброса |
| 0x08000008 | 0x008 | `NMI_Handler` |
| 0x0800000C | 0x00C | `HardFault_Handler` |
| 0x08000010 | 0x010 | `MemManage_Handler` |
| ... | ... | ... |
| 0x080000D4 | 0x0D4 | `USART1_IRQHandler` — прерывание UART1 |
| ... | ... | ... |
| 0x08000108 | 0x108 | `BootRAM` (маркер) |

Это 76 слов (304 байта) в самом начале Flash.

Вручную менять не нужно. Она обновляется автоматически при сборке:

- Каждый Handler объявлен как `.weak` — по умолчанию все указывают на `Default_Handler` (бесконечный цикл)
- Когда пишется в C-коде функция с точно таким именем (например `USART1_IRQHandler` в `stm32f1xx_it.c`), линкер автоматически подставляет адрес функции вместо `Default_Handler`
- Если добавить через CubeMX новое прерывание (например I2C1), CubeMX сгенерирует обработчик в `stm32f1xx_it.c`, и при сборке линкер сам подставит его адрес в таблицу
- Единственный случай, когда таблицу перемещают — это bootloader-сценарий (запись VTOR регистра). В этом проекте этого нет — таблица всегда по адресу `0x08000000`


```asm
g_pfnVectors:
  .word _estack          ← MSP (указатель стека)
  .word Reset_Handler    ← PC  (первая инструкция)
  .word NMI_Handler      ← вектор NMI
  .word HardFault_Handler
  ...                    ← ещё 59 векторов прерываний
```

---

## Фаза 1: Reset_Handler (ассемблер, startup_stm32f103c8tx.s)

**Именно здесь остановился отладчик** (строка 64). Это ассемблерный код, который готовит C-среду:

```
Reset_Handler (0x08001278)
    │
    ├─ 1. bl SystemInit
    │     Минимальная настройка: сброс регистров тактирования RCC,
    │     установка VTOR (адрес таблицы векторов = 0x08000000).
    │     После этого процессор всё ещё на внутреннем RC-генераторе 8 МГц.
    │
    ├─ 2. Копирование .data из Flash в RAM
    │     Инициализированные глобальные переменные (например, char wr_data[7] = {'K','U',...})
    │     хранятся во Flash. Startup копирует их в RAM-адреса (_sdata → _edata).
    │
    ├─ 3. Обнуление .bss в RAM
    │     Неинициализированные глобальные переменные (например, uint8_t uart1_rx_head = 0)
    │     заполняются нулями (_sbss → _ebss).
    │
    ├─ 4. bl __libc_init_array
    │     Вызов C-конструкторов (static init, newlib init).
    │
    └─ 5. bl main
          Переход в main() — С-код.
```

### Карта памяти на этом этапе

```
FLASH (64 KB)                          RAM (20 KB)
0x08000000 ┌──────────────┐           0x20000000 ┌──────────────┐
           │ .isr_vector  │ 304 B                │ .data        │ ← скопировано из Flash
           │ (таблица     │                      │ (глобальные  │
           │  векторов)   │                      │  с начальным │
           ├──────────────┤                      │  значением)  │
           │ .text        │                      ├──────────────┤
           │ (весь код)   │                      │ .bss         │ ← обнулено
           │              │                      │ (глобальные  │
           ├──────────────┤                      │  без значения)│
           │ .rodata      │                      ├──────────────┤
           │ (строки,     │                      │ Heap (malloc)│ 512 B
           │  константы)  │                      ├──────────────┤
           ├──────────────┤                      │ Stack (MSP)  │ 1 KB
           │ .data init   │                      │ (главный и   │
           │ (образ для   │───копирование──▶     │  прерывания) │
           │  RAM)        │                      ├──────────────┤
           └──────────────┘           0x20005000 │ _estack      │ ← MSP стартует тут
                                                 └──────────────┘
```

---

## Фаза 2: main() — инициализация (до запуска FreeRTOS)

```c
main()
  │
  ├─ 1. Сохранение причины сброса
  │     reset_cause = RCC->CSR;   // Читаем флаги (POR, PIN, WDG, SW...)
  │     RCC->CSR |= RCC_CSR_RMVF; // Очищаем флаги
  │
  ├─ 2. HAL_Init()
  │     ├─ Настройка Flash prefetch
  │     ├─ Запуск SysTick → HAL_GetTick() начинает считать миллисекунды
  │     ├─ Настройка NVIC приоритетов (группы 4: все биты = preemption)
  │     └─ Время тактирования: всё ещё HSI 8 МГц
  │
  ├─ 3. SystemClock_Config()
  │     HSE 8 МГц (кварц) → PLL ×9 → SYSCLK = 72 МГц
  │     ├─ AHB = 72 МГц (без деления)
  │     ├─ APB1 = 36 МГц (÷2) — для USART2/3, SPI2, I2C, TIM2-4
  │     ├─ APB2 = 72 МГц (÷1) — для USART1, SPI1, TIM1, GPIO
  │     └─ Flash latency = 2 wait states (для 72 МГц)
  │
  ├─ 4. Инициализация периферии
  │     ├─ MX_GPIO_Init()
  │     │   ├─ Включить тактирование GPIOC, GPIOD, GPIOA
  │     │   ├─ PC13, PC15 → выход (LED, индикатор активности)
  │     │   └─ PA4 → выход (FRAM chip select)
  │     │
  │     ├─ MX_USART1_UART_Init()
  │     │   ├─ USART1: 38400 бод, 8N1
  │     │   └─ HAL_UART_Receive_IT() → запуск приёма первого байта по прерыванию
  │     │
  │     ├─ MX_USART3_UART_Init()
  │     │   └─ USART3: 115200 бод, 8N1 (отладочный вывод)
  │     │
  │     └─ MX_SPI1_Init()
  │         └─ SPI1: Master, 4.5 МГц, CPOL=0 CPHA=0, Software NSS
  │
  ├─ 5. Лог в UART3
  │     "Rst:0x________"      ← причина последнего сброса
  │     "Main started, time: XXX ms"
  │
  ├─ 6. FRAM
  │     fram_cfg_setup() + fram_init() → готовность SPI FRAM
  │
  ├─ 7. osKernelInitialize()
  │     ├─ Инициализация FreeRTOS ядра
  │     ├─ Создание Idle-задачи (внутренняя, приоритет 0)
  │     └─ Выделение heap (10 KB из RAM) для задач
  │
  ├─ 8. Создание очереди и задач
  │     ├─ uartQueue = xQueueCreate(40, 1)     ← очередь 40 байт
  │     ├─ osThreadNew(StartDefaultTask, 1024B, Normal)
  │     ├─ osThreadNew(LedTask, 512B, Normal)
  │     └─ osThreadNew(Uart1Task, 2048B, AboveNormal)
  │
  └─ 9. osKernelStart()
        ├─ Запуск планировщика FreeRTOS
        ├─ Настройка SysTick для FreeRTOS (1 кГц тик)
        ├─ Переключение на первую задачу с наивысшим приоритетом
        └─ *** main() больше НИКОГДА не возвращается ***
```

---

## Фаза 3: Работающая система (FreeRTOS)

После `osKernelStart()` управление полностью у планировщика. Три задачи + Idle работают по вытеснению:

```
Время →
         ┌─────┐     ┌─────┐     ┌─────┐
Uart1Task│ run │     │ run │     │ run │   Приоритет: AboveNormal (25)
(2048B)  └──┬──┘     └──┬──┘     └──┬──┘   Обработка команд UART1
            │           │           │
     ┌──────┴─────┬─────┴──────┬────┴──────┐
     │   ┌───┐    │   ┌───┐   │   ┌───┐   │
Dflt │   │run│    │   │run│   │   │run│   │   Приоритет: Normal (24)
(1024B)  └─┬─┘        └─┬─┘       └─┬─┘       Диагностика каждые 5с
           │             │           │
     ┌─────┴───┬─────────┴───┬───────┴─────┐
     │ ┌──┐    │   ┌──┐     │   ┌──┐      │
Led  │ │r │    │   │r │     │   │r │      │   Приоритет: Normal (24)
(512B) └──┘        └──┘         └──┘           LED каждые 1с
     │         │             │             │
     │  ┌──────┴─────────────┴─────────────┴─
Idle │  │████████████████████████████████████  Приоритет: 0
     │  └────────────────────────────────────  Работает когда все спят
```

### Задача: Uart1Task (обработка команд)

```
Uart1Task (приоритет AboveNormal)
    │
    ├─ uart1_put_ch('S')           ← сигнал «задача запущена»
    │
    └─ Бесконечный цикл:
         │
         ├─ Toggle PC15             ← индикация активности
         │
         ├─ xQueueReceive(uartQueue, 2мс таймаут)
         │   ├─ Есть байт → добавить в command[index++]
         │   └─ Нет байта → пропустить
         │
         ├─ Проверка таймаута (20мс тишины = конец кадра):
         │   │
         │   └─ Если index > 0 И прошло > 20мс с последнего байта:
         │       │
         │       ├─ process_crc(command, index, true)
         │       │   └─ CRC16-MODBUS проверка
         │       │
         │       ├─ Если CRC верна:
         │       │   ├─ command[0] == 0x70 → GPIO управление LED
         │       │   │   ├─ [1]==0 → PC13 HIGH
         │       │   │   └─ [1]==1 → PC13 LOW
         │       │   │
         │       │   └─ command[0] == 0x02 → FRAM тест
         │       │       └─ Запись/чтение "KUREIN" по адресу 0x0150
         │       │
         │       ├─ Отправить ответ: [ID_BU, 0x00, CRC_L, CRC_H]
         │       ├─ Очистить очередь (сбросить мусор)
         │       └─ index = 0
         │
         └─ vTaskDelay(3мс)         ← отдать CPU другим задачам
```

### Задача: StartDefaultTask (диагностика)

```
StartDefaultTask (приоритет Normal)
    │
    ├─ printf_uart3("Default Task running...")
    │
    └─ Каждую секунду:
         │
         ├─ printf_uart3("Tick:%lu", HAL_GetTick())
         │
         └─ Каждые 5 секунд (доп. диагностика):
              ├─ HeapB F:XXXX Min:XXXX Tot:10240
              ├─ HeapU now:XX% peak:XX%
              ├─ StkB free D:XXX L:XXX U:XXX
              └─ StkU % D:XX L:XX U:XX
```

### Задача: LedTask (светодиод)

```
LedTask (приоритет Normal)
    │
    └─ Каждые 1с:
         └─ HAL_GPIO_TogglePin(PC13)    ← LED мигает
```

---

## Обработка прерывания UART1 (ISR-контекст)

Это происходит **вне задач**, в контексте прерывания:

```
Байт приходит по UART1 (PA10)
         │
         ▼
USART1_IRQHandler()                    ← аппаратное прерывание (приоритет 5)
    │
    └─ HAL_UART_IRQHandler(&huart1)
         │
         └─ HAL_UART_RxCpltCallback()  ← наш callback в uart.c
              │
              ├─ Читаем байт из uart1_rx_buf[head]
              │
              ├─ Продвигаем head (кольцевой буфер)
              │   └─ Если буфер полон → сброс head=0, tail=0
              │
              ├─ xQueueSendFromISR(uartQueue, &ch)
              │   └─ Байт → очередь → Uart1Task проснётся
              │
              ├─ last_rx_time = xTaskGetTickCountFromISR()
              │   └─ Метка времени для детекции конца кадра
              │
              ├─ HAL_UART_Receive_IT(..., 1)
              │   └─ Перезапуск приёма следующего байта
              │
              └─ portYIELD_FROM_ISR() если Uart1Task имеет
                 более высокий приоритет, чем текущая задача
```

---

## Полная временная линия (первые ~2 секунды)

```
t=0мс     ─── Питание / Сброс ───
          │ Cortex-M3: MSP = 0x20005000, PC = Reset_Handler
          │
t~0.001мс │ Reset_Handler: SystemInit()
          │ Копирование .data, обнуление .bss
          │ __libc_init_array()
          │ Прыжок в main()
          │
t~0.01мс  │ main(): HAL_Init(), SysTick запущен
          │
t~0.1мс   │ SystemClock_Config(): HSE 8МГц → PLL → 72МГц
          │ Теперь всё работает на полной скорости
          │
t~0.5мс   │ GPIO, UART1, UART3, SPI1 инициализированы
          │ UART1 прерывание включено (ожидание первого байта)
          │
t~1мс     │ UART3: "Rst:0x24000000"
          │
t~1001мс  │ HAL_Delay(1000) — пауза 1 секунда
          │ UART3: "Main started, time: 1001 ms"
          │
t~1002мс  │ FRAM init
          │
t~1003мс  │ osKernelInitialize() + создание очереди + 3 задачи
          │
t~1004мс  │ osKernelStart()
          │ ═══════════════════════════════════════
          │ *** С этого момента — FreeRTOS ***
          │ *** main() больше не выполняется ***
          │ ═══════════════════════════════════════
          │
t~1005мс  │ Uart1Task: uart1_put_ch('S')
          │ StartDefaultTask: "Default Task running..."
          │ LedTask: первый toggle PC13
          │
t~2005мс  │ StartDefaultTask: "Tick:2005"
          │ LedTask: второй toggle PC13
          │
t~6005мс  │ StartDefaultTask: первый вывод диагностики
          │   HeapB / HeapU / StkB / StkU
          │
          └─── ... система работает бесконечно ───
```

---

## Про ошибку в отладчике

Сообщение:
```
Error: A serious error occurred with gdb, unable to continue or interrupt
```

### Причина №1: Слишком много breakpoints (самая частая)

STM32F103C8 (Cortex-M3) имеет всего **6 аппаратных breakpoints**. Поскольку код выполняется из Flash (read-only), программные breakpoints невозможны — используются только аппаратные.

При этом `runToEntryPoint: "main"` в launch.json автоматически добавляет **ещё 1 временный breakpoint** на `main()`. Если в редакторе стоит 6 точек останова, то суммарно будет 7 — и GDB не сможет вставить последний:

```
Cannot insert hardware breakpoint 6.
Could not insert hardware breakpoints:
You may have requested too many hardware breakpoints/watchpoints.
```

**Решение:** убрать лишние breakpoints, чтобы сумма (ваши + 1 от `runToEntryPoint`) не превышала 6.

| Ресурс | Лимит | Примечание |
|--------|-------|-----------|
| Hardware breakpoints | 6 | Физическое ограничение Cortex-M3 |
| Hardware watchpoints | 4 | Для отслеживания изменения переменных |
| `runToEntryPoint` | -1 слот | Автоматический временный breakpoint |
| **Доступно пользователю** | **5** | При включённом `runToEntryPoint: "main"` |

### Причина №2: RTOS awareness

Если `"rtos": "FreeRTOS"` включён в launch.json, GDB пытается найти структуры FreeRTOS до того, как ядро инициализировано. Решение — убрать эту настройку.

### Причина №3: Потеря связи

GDB может потерять связь с процессором при переключении контекста FreeRTOS или step через startup-ассемблер. Решение — не ставить breakpoint в startup-коде, начинать отладку с `main()`.

---

*Файлы: `startup_stm32f103c8tx.s` → `system_stm32f1xx.c` → `main.c` → `uart.c`*
*Linker: `STM32F103C8TX_FLASH.ld` (RAM: 20K, Flash: 64K)*
