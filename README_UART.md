# README_UART.md

Этот файл описывает, как в проекте `primGPT` реализован прием/передача по UART, как фиксируется конец посылки и как работает таймаут.

---

## 1) Какие UART используются

- `USART1` (`PA9` TX, `PA10` RX, 38400 бод) - командный интерфейс.
- `USART3` (`PB10` TX, `PB11` RX, 115200 бод) - отладочный/лог-канал.

Основная логика протокола находится на `USART1`.

---

## 2) Как устроен прием в текущем коде

### Ключевая идея

Прием сделан по схеме:

1. Запускается прием одного байта по прерыванию (`HAL_UART_Receive_IT(..., 1)`).
2. После каждого байта вызывается callback `HAL_UART_RxCpltCallback()`.
3. ISR кладет байт в очередь FreeRTOS (`xQueueSendFromISR`).
4. Задача `Uart1Task` забирает байты из очереди (`xQueueReceive`) и собирает кадр.

Это правильный паттерн для RTOS: ISR короткий, тяжелая логика живет в задаче.

---

## 3) Как фиксируется конец посылки

В текущей реализации конец кадра определяется **по паузе между байтами**.

Механизм:

- при каждом принятом байте ISR обновляет `last_rx_time = xTaskGetTickCountFromISR();`
- в `Uart1Task` периодически считается:
  - `current_time = xTaskGetTickCount();`
  - `diff = current_time - last_rx_time;`
- если:
  - уже накоплены байты (`index > 0`), и
  - `diff > UART_TIMEOUT_MS`,
  то система считает, что посылка завершилась.

После этого:
- проверяется CRC (`process_crc(..., true)`);
- выполняется команда;
- отправляется ответ;
- буфер/очередь сбрасываются для следующего кадра.

---

## 4) Как задается таймаут сейчас

Таймаут задается константой:

- `UART_TIMEOUT_MS = 200` (в `DataFile.h`).

Важно: это **фиксированное значение**, оно не вычисляется автоматически от baud rate.

---

## 5) Связь таймаута со скоростью передачи (теория)

Обычно длительность одного символа UART (формат 8N1) оценивают как:

- `t_char ~= 10 / baud`.

Для 38400 бод:

- `t_char ~= 10 / 38400 ~= 0.26 ms`.

Тогда межсимвольный разрыв можно выбирать, например:

- 3.5 символа: `~0.91 ms`,
- 10 символов: `~2.6 ms`,
- с инженерным запасом: 2..10 ms (зависит от линии, ОС мастера, джиттера).

На фоне этих чисел текущий `200 ms` - очень большой таймаут (надежно, но медленно по реакции на конец кадра).

---

## 6) Плюсы и минусы текущего подхода (по паузе)

### Плюсы

- Очень простая реализация.
- Не нужен отдельный байт конца кадра.
- Работает с бинарными данными (если CRC валидирует кадр).

### Минусы

- Задержка обработки зависит от `UART_TIMEOUT_MS`.
- При большом таймауте растет latency.
- При слишком маленьком таймауте возможна "нарезка" одного кадра на несколько.
- Нет явной длины кадра (`LEN`), поэтому сложнее строго валидировать размер до CRC.

---

## 7) Какие есть альтернативы завершения кадра

### Вариант A: явная длина кадра

Формат: `SOF | LEN | CMD | PAYLOAD | CRC16`.

Плюсы:
- детерминированный парсинг;
- быстро понятно, сколько байт ждать;
- меньше зависимости от таймаута.

### Вариант B: разделитель конца кадра

Формат: `... | EOF`.

Плюсы:
- просто в ASCII-протоколах.

Минусы:
- для бинарного протокола нужно экранирование байтов.

#### Важно про EOF в разных ОС

Для UART-протокола полезно понимать: в ОС "EOF" обычно не является байтом в данных, это событие конца потока/ввода.

- Linux/macOS (терминал): EOF-сигнал обычно вводится `Ctrl+D`.
- Windows Console (cmd/PowerShell): EOF-сигнал обычно `Ctrl+Z`, затем `Enter`.

Бинарные значения этих управляющих кодов:

- `Ctrl+D` -> `EOT` -> `0x04` -> `0000 0100`
- `Ctrl+Z` -> `SUB` -> `0x1A` -> `0001 1010`

Часто путают с "концом строки":
- Unix-стиль перевод строки: `LF` (`0x0A`);
- Windows-стиль перевод строки: `CRLF` (`0x0D 0x0A`);
- старый Mac-стиль: `CR` (`0x0D`).

Если в вашем протоколе хотите именно "байт конца кадра", его нужно выбрать явно (например `0x0A` или `0x7E`) и описать в спецификации. Универсального "EOF-байта ОС" для UART не существует.

### Вариант C: чисто таймаут (как сейчас)

Плюсы:
- минимум протокольной обвязки.

Минусы:
- чувствительность к выбранному значению таймаута.

---

## 8) Почему в проекте используется `xQueueSendFromISR`, а не `xQueueSend`

- `xQueueSendFromISR` - специальная ISR-safe функция.
- Ее можно вызывать в обработчике прерывания.
- Она умеет корректно запросить переключение контекста (`xHigherPriorityTaskWoken`), если пробужденная задача должна выполняться немедленно.

Обычную `xQueueSend` из ISR вызывать нельзя.

---

## 9) Практические рекомендации для этого проекта

1. Оставить текущую схему, если важна простота и небольшой поток команд.
2. Уменьшить `UART_TIMEOUT_MS` (например, до 5..20 ms) после тестов на реальной линии.
3. Для роста протокола перейти на кадр с `LEN` и CRC.
4. В долгосрочной перспективе рассмотреть DMA RX + ring buffer + parser task (лучше масштабируется).

---

## 10) Краткое резюме

В `primGPT` конец приема посылки на `UART1` фиксируется не "специальным байтом", а паузой:

- "Если после последнего принятого байта прошло больше `UART_TIMEOUT_MS`, кадр завершен".

Это рабочий и распространенный способ, но его качество сильно зависит от правильно выбранного таймаута.

