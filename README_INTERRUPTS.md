# README_INTERRUPTS.md

Этот документ объясняет систему прерываний в проекте `primGPT`: какие прерывания используются, как они связаны с FreeRTOS, и как безопасно развивать ISR-логику дальше.

---

## 1) Зачем нужны прерывания в этом проекте

Прерывания используются для реакции на события "из железа" без постоянного опроса (polling):

- прием байтов по `USART1` (командный канал);
- системный тайм-базис через `TIM1_UP` (в данном проекте HAL time base сделан через TIM1);
- RTOS-переключения контекста (`SysTick`, `PendSV`, `SVC`) на уровне ядра.

Главный принцип: ISR должна быть короткой, тяжелую логику переносить в задачу.

---

## 2) Какие прерывания реально задействованы

### Cortex-M системные

- `SVC_Handler` - служебный вход в RTOS.
- `PendSV_Handler` - отложенное переключение контекста задач.
- `SysTick_Handler` - системный тик (в связке с RTOS/HAL, в проекте time base через TIM1).
- Fault IRQ (`HardFault`, `MemManage`, `BusFault`, `UsageFault`) - аварийные обработчики, в коде уходят в бесконечный цикл.

### Периферийные

- `USART1_IRQHandler`:
  - вызывает `HAL_UART_IRQHandler(&huart1)`;
  - дальше HAL вызывает callback `HAL_UART_RxCpltCallback()` из `uart.c`.

- `TIM1_UP_IRQHandler`:
  - вызывает `HAL_TIM_IRQHandler(&htim1)`;
  - через `HAL_TIM_PeriodElapsedCallback()` инкрементируется HAL tick (`HAL_IncTick()`).

---

## 3) Наглядный поток по прерыванию UART1

```text
Внешний байт на PA10 (USART1_RX)
   ->
USART1 IRQ
   ->
USART1_IRQHandler()
   ->
HAL_UART_IRQHandler(&huart1)
   ->
HAL_UART_RxCpltCallback()
   ->
xQueueSendFromISR(uartQueue, byte, &xHigherPriorityTaskWoken)
   ->
HAL_UART_Receive_IT(..., 1)   // перезапуск приема следующего байта
   ->
portYIELD_FROM_ISR(...)       // при необходимости переключить контекст
   ->
Uart1Task в task context получает байт и обрабатывает кадр
```

Это ключевой путь "ISR producer -> queue -> task consumer".

---

## 4) Приоритеты NVIC и связь с FreeRTOS

По конфигурации проекта:

- `configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY = 5`.
- `USART1_IRQn` имеет приоритет `5`.
- `PendSV_IRQn` и `SysTick_IRQn` стоят на низком приоритете ядра (`15`).

Почему это важно:

- ISR, которые вызывают API `...FromISR` (например `xQueueSendFromISR`), должны иметь корректный (не слишком высокий) приоритет относительно `configMAX_SYSCALL_INTERRUPT_PRIORITY`.
- В вашем случае `USART1_IRQn = 5` согласован с конфигом FreeRTOS.

---

## 5) Что разрешено и что нежелательно делать в ISR

### Разрешено (и рекомендуется)

- Читать/фиксировать факт события.
- Класть короткие данные в очередь (`xQueueSendFromISR`).
- Обновлять простой таймштамп (`last_rx_time`).
- Перезапускать прием следующего байта (`HAL_UART_Receive_IT`).

### Нежелательно в ISR

- Долгие циклы и большая обработка протокола.
- Блокирующие вызовы (`HAL_Delay`, ожидания с таймаутами).
- Тяжелые `printf`.
- Вызовы не-ISR-safe API FreeRTOS.

---

## 6) Как именно реализован ISR-уровень в `uart.c`

В callback `HAL_UART_RxCpltCallback()` для `USART1`:

1. Берется принятый байт из RX-буфера.
2. Обновляется индекс кольцевого буфера.
3. Байт отправляется в очередь `uartQueue` через `xQueueSendFromISR`.
4. Обновляется `last_rx_time` через `xTaskGetTickCountFromISR`.
5. Прием следующего байта снова запускается через `HAL_UART_Receive_IT`.
6. При необходимости вызывается `portYIELD_FROM_ISR`.

За счет этого каждый байт "быстро передается" из IRQ в задачу, а не разбирается полностью в ISR.

---

## 7) Типичные ошибки при развитии ISR-части

1. Добавление тяжелой логики парсинга прямо в callback.
2. Вызов обычных API FreeRTOS вместо `...FromISR`.
3. Неверные NVIC-приоритеты для прерываний, использующих RTOS API.
4. Отсутствие повторного `HAL_UART_Receive_IT` (прием "останавливается" после одного байта).
5. Переполнение очереди без учета ошибок и статистики.

---

## 8) Как развивать подсистему прерываний дальше

### Шаг 1. Диагностика стабильности

- Считать счетчики:
  - принятых байтов,
  - пропусков/overflow,
  - ошибок кадра/CRC.

### Шаг 2. Улучшение пути RX

- Рассмотреть `DMA RX + ring buffer` вместо "1 байт на IRQ":
  - меньше ISR-нагрузка,
  - лучше масштабируется на больших скоростях.

### Шаг 3. Усиление защиты

- Добавить обработку ошибок UART (`ORE/FE/NE`) и recovery-путь.
- Проверить запас глубины очереди под худшие сценарии.

### Шаг 4. Стандартизация протокола

- Перейти на явную структуру кадра (`LEN`) для более детерминированной обработки в задаче.

---

## 9) Краткое резюме

В `primGPT` прерывания организованы корректно для RTOS-подхода:

- ISR короткие;
- данные передаются в задачу через очередь;
- командная логика и CRC работают в task context;
- NVIC-приоритеты согласованы с использованием `FromISR` API.

Это хорошая база для дальнейшего роста (DMA, richer protocol, лучшая диагностика).

