# README_RAM_RTOS.md

Подробное руководство по памяти и RTOS-диагностике для проекта `primGPT` на `STM32F103C8`.

Документ объясняет:
- как устроена RAM в этом проекте;
- что показывают логи `Heap` и `Stk`, которые выводятся в `StartDefaultTask`;
- как понять, где риск переполнения;
- как безопасно уменьшать потребление памяти.

---

## 1) Почему это критично именно для STM32F103C8

У `STM32F103C8` RAM очень маленькая: примерно `20 KB` (`0x5000`, 20480 байт).

В такой системе даже несколько "лишних" буферов/стеков легко приводят к:
- нестабильной работе;
- случайным зависаниям;
- `HardFault`;
- непредсказуемым сбоям после "незначительных" изменений кода.

Поэтому мониторинг heap/stack в рантайме для этого проекта обязателен.

---

## 2) Как память делится в вашей прошивке

В общем виде RAM делится на несколько частей:

1. `.data`  
   Глобальные/статические переменные с инициализацией (копируются из Flash в RAM при старте).

2. `.bss`  
   Глобальные/статические переменные без инициализации (зануляются при старте).

3. FreeRTOS heap  
   Пул памяти для динамики FreeRTOS (задается `configTOTAL_HEAP_SIZE`).
   В вашем проекте: `14 KB` (`Core/Inc/FreeRTOSConfig.h`).

4. Main stack / interrupt stack (MSP)  
   Стек прерываний и старта (настраивается линкером/startup).

5. Task stacks  
   Для каждой задачи выделяется свой стек (в вашем проекте через `osThreadNew` и `stack_size`).

6. Библиотечные накладные расходы  
   `newlib`, временные буферы, внутренние структуры HAL/RTOS.

---

## 3) Что вы уже добавили в код (диагностика)

В `StartDefaultTask` сейчас печатаются:

- `Heap:%u/%u`
  - первое число: текущее свободное место в heap (`xPortGetFreeHeapSize`);
  - второе число: минимальный исторический остаток (`xPortGetMinimumEverFreeHeapSize`).

- `Stk:%u,%u,%u`
  - watermark стека трех задач через `uxTaskGetStackHighWaterMark`:
    1) `defaultTask`,
    2) `LedTask`,
    3) `Uart1Task`.

Печать идет раз в 5 секунд.

---

## 4) Самое важное: как правильно читать `Stk`

`uxTaskGetStackHighWaterMark()` возвращает **не байты**, а количество "слов стека" (`StackType_t`).

Для Cortex-M3 (`STM32F1`) размер слова = `4 байта`.

Значит:

- `stack_free_bytes ~= watermark_words * 4`.

Пример:
- если в логе `Stk:40,60,120`,
- то свободно примерно:
  - `defaultTask`: `160 B`,
  - `LedTask`: `240 B`,
  - `Uart1Task`: `480 B`.

### Практический смысл watermark

Watermark - это "минимальный запас", который когда-либо оставался.
То есть это индикатор худшего случая за время работы.

Чем меньше watermark -> тем ближе задача к переполнению стека.

---

## 5) Как читать `Heap:%u/%u`

Для пары `Heap:free/min`:

- `free` - сколько heap свободно прямо сейчас;
- `min` - насколько глубоко heap "проседал" в худший момент.

Именно `min` важнее для надежности.

Если `min` очень маленький, значит при пиковой нагрузке вы почти исчерпываете heap.

---

## 6) Грубые безопасные пороги (практика)

Для этого класса MCU удобно ориентироваться так:

### Heap

- `min_heap > 1024 B` - обычно комфортно.
- `min_heap 512..1024 B` - уже зона внимания.
- `min_heap < 512 B` - рискованно, особенно при росте функционала.

### Task stack (в байтах, после перевода из words)

- запас > `256 B` - обычно ок.
- запас `128..256 B` - нужно наблюдать.
- запас < `128 B` - лучше увеличить стек задачи.
- запас < `64 B` - высокая вероятность stack overflow при изменениях.

Это не "закон", а рабочие инженерные ориентиры.

---

## 7) Почему может быть `HardFault`, даже если "сборка успешна"

Сборка проверяет только компиляцию/линковку, но не runtime-пики.

Частые причины падений:

1. Переполнение стека задачи
- много локальных массивов;
- глубокие цепочки вызовов;
- `printf`-подобные функции в задаче с маленьким стеком.

2. Исчерпание FreeRTOS heap
- создание новых объектов RTOS (queue/semaphore/task/timer);
- неожиданные буферы и аллокации библиотек.

3. Переполнение буферов
- выход за границы массива;
- некорректная длина кадра.

---

## 8) Почему в вашем проекте риск повышенный

По вашему логу сборки ранее:
- `data + bss` уже очень близко к 20 KB RAM,
- при этом есть FreeRTOS heap 14 KB + стеки задач.

Это значит, что проект работает близко к пределу и требует строгого контроля:
- `min_heap`,
- stack watermark всех задач,
- отсутствие крупных локальных буферов.

---

## 9) Как быстро снизить риск (пошагово)

## Шаг 1. Собрать реальные метрики

Погонять устройство под реальной нагрузкой (команды UART, FRAM операции, логирование) и записать:
- минимум `min_heap`;
- минимальные watermark по каждой задаче.

## Шаг 2. Подобрать стеки задач по факту

Если watermark задачи стабильно большой, можно уменьшить ее `stack_size`.
Если маленький - увеличить.

Цель: у каждой задачи оставить разумный запас, но не "переразмерять".

## Шаг 3. Сократить вывод `printf`

`printf` дорог по стеку и времени.
Полезно:
- укоротить строки;
- уменьшить частоту логов;
- избегать тяжелого форматирования в горячих участках.

## Шаг 4. Убрать большие локальные массивы

Локальные массивы бьют по стеку задачи.
Где возможно:
- использовать статические буферы;
- переиспользовать один буфер;
- держать буферы минимального необходимого размера.

## Шаг 5. Пересмотреть `configTOTAL_HEAP_SIZE`

Если heap стабильно избыточный, можно слегка уменьшить.
Если `min_heap` маленький - наоборот увеличить (но помня, что RAM общая и маленькая).

---

## 10) Важный момент про единицы измерения стеков

В проекте размер задачи задается в `osThreadAttr_t.stack_size`.
В CMSIS-RTOS V2 это задается в байтах, а внутри FreeRTOS преобразуется в слова.

А вот `uxTaskGetStackHighWaterMark()` возвращает слова.

Итог:
- при настройке `stack_size` думаем в байтах;
- при чтении watermark переводим `words -> bytes` умножением на 4.

---

## 11) Мини-шпаргалка для ежедневной проверки

После каждого заметного изменения прошивки:

1. Проверить, что устройство стабильно работает 10-30 минут.
2. Снять логи `Heap` и `Stk` под нагрузкой.
3. Оценить:
   - `min_heap`,
   - минимальный запас стека каждой задачи.
4. Если запас маленький - корректировать до появления комфортного резерва.

---

## 12) Как развивать диагностику дальше

Если захотите следующий уровень, можно добавить:

- печать watermark в байтах (сразу, без ручного пересчета);
- `vApplicationStackOverflowHook` для явной детекции переполнения стека;
- `vApplicationMallocFailedHook` для контроля ошибок heap;
- периодический отчет по очередям (`uxQueueMessagesWaiting`, max occupancy);
- отдельный "health task" с watchdog-пингом.

---

## 13) Краткий вывод

Для `STM32F103C8` память - главный ограничивающий ресурс.

Ваш текущий путь правильный:
- добавлен runtime-контроль heap/stack;
- задержки в задаче переведены на RTOS delay;
- можно принимать решения по стеку и heap на основе фактических метрик, а не "на глаз".

Самое главное правило:
- ориентироваться не на "средние" значения, а на худший случай (`min_heap` и минимальный watermark).

