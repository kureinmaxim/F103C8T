# README_RAM_RTOS.md

Подробное руководство по памяти и RTOS-диагностике для проекта `primGPT` на `STM32F103C8`.

Документ объясняет:
- как устроена RAM в этом проекте;
- что показывают логи `Heap` и `Stk`, которые выводятся в `StartDefaultTask`;
- как понять, где риск переполнения;
- как безопасно уменьшать потребление памяти.

---

## 1) Почему это критично именно для STM32F103C8

У `STM32F103C8` RAM очень маленькая: примерно `20 KB` (`0x5000`, 20480 байт).

В такой системе даже несколько "лишних" буферов/стеков легко приводят к:
- нестабильной работе;
- случайным зависаниям;
- `HardFault`;
- непредсказуемым сбоям после "незначительных" изменений кода.

Поэтому мониторинг heap/stack в рантайме для этого проекта обязателен.

---

## 2) Как память делится в вашей прошивке

В общем виде RAM делится на несколько частей:

1. `.data`  
   Глобальные/статические переменные с инициализацией (копируются из Flash в RAM при старте).

2. `.bss`  
   Глобальные/статические переменные без инициализации (зануляются при старте).

3. FreeRTOS heap  
   Пул памяти для динамики FreeRTOS (задается `configTOTAL_HEAP_SIZE`).
   В вашем проекте: `14 KB` (`Core/Inc/FreeRTOSConfig.h`).

4. Main stack / interrupt stack (MSP)  
   Стек прерываний и старта (настраивается линкером/startup).

5. Task stacks  
   Для каждой задачи выделяется свой стек (в вашем проекте через `osThreadNew` и `stack_size`).

6. Библиотечные накладные расходы  
   `newlib`, временные буферы, внутренние структуры HAL/RTOS.

---

## 3) Что сейчас печатается в диагностике (актуально)

В `StartDefaultTask` сейчас печатаются 4 строки:

- `HeapB F:%u Min:%u Tot:%u`
  - `F` - текущее свободное место в heap (`xPortGetFreeHeapSize`);
  - `Min` - минимальный исторический остаток (`xPortGetMinimumEverFreeHeapSize`);
  - `Tot` - общий размер heap (`configTOTAL_HEAP_SIZE`).

- `HeapU now:%u%% peak:%u%%`
  - `now` - текущий процент использования heap;
  - `peak` - максимальный процент использования heap за время работы.

- `StkB free D:%u L:%u U:%u`
  - минимальный свободный запас стека (watermark, уже в байтах) для:
    - `D` = `defaultTask`,
    - `L` = `LedTask`,
    - `U` = `Uart1Task`.

- `StkU %% D:%u L:%u U:%u`
  - процент занятого стека для тех же задач (`D/L/U`).

Печать идет раз в 5 секунд.

---

## 4) Самое важное: как правильно читать `Stk`

`uxTaskGetStackHighWaterMark()` возвращает **не байты**, а количество "слов стека" (`StackType_t`).

Для Cortex-M3 (`STM32F1`) размер слова = `4 байта`.

Значит:

- `stack_free_bytes ~= watermark_words * 4`.

Пример:
- если в логе `Stk:40,60,120`,
- то свободно примерно:
  - `defaultTask`: `160 B`,
  - `LedTask`: `240 B`,
  - `Uart1Task`: `480 B`.

### Практический смысл watermark

Watermark - это "минимальный запас", который когда-либо оставался.
То есть это индикатор худшего случая за время работы.

Чем меньше watermark -> тем ближе задача к переполнению стека.

---

## 5) Как читать `HeapB` и `HeapU`

Для строк:

- `HeapB F:free Min:min Tot:total`
- `HeapU now:X% peak:Y%`

интерпретация такая:

- `free` - сколько heap свободно прямо сейчас;
- `min` - насколько глубоко heap проседал в худший момент;
- `total` - размер heap в байтах;
- `now` - текущее использование heap: `(total - free) / total`;
- `peak` - пиковое использование heap: `(total - min) / total`.

Именно `min` важнее для надежности.

Если `min` очень маленький, значит при пиковой нагрузке вы почти исчерпываете heap.

---

## 6) Грубые безопасные пороги (практика)

Для этого класса MCU удобно ориентироваться так:

### Heap

- `min_heap > 1024 B` - обычно комфортно.
- `min_heap 512..1024 B` - уже зона внимания.
- `min_heap < 512 B` - рискованно, особенно при росте функционала.

### Task stack (в байтах и процентах)

- запас > `256 B` - обычно ок.
- запас `128..256 B` - нужно наблюдать.
- запас < `128 B` - лучше увеличить стек задачи.
- запас < `64 B` - высокая вероятность stack overflow при изменениях.
- запас `0 B` - критично, стек задачи уже полностью выбран в худшем случае.

Для процента из `StkU`:

- < `70%` - обычно комфортно;
- `70..85%` - рабочая зона наблюдения;
- > `85%` - лучше увеличить стек;
- `100%` - критично.

Это не "закон", а рабочие инженерные ориентиры.

---

## 7) Почему может быть `HardFault`, даже если "сборка успешна"

Сборка проверяет только компиляцию/линковку, но не runtime-пики.

Частые причины падений:

1. Переполнение стека задачи
- много локальных массивов;
- глубокие цепочки вызовов;
- `printf`-подобные функции в задаче с маленьким стеком.

2. Исчерпание FreeRTOS heap
- создание новых объектов RTOS (queue/semaphore/task/timer);
- неожиданные буферы и аллокации библиотек.

3. Переполнение буферов
- выход за границы массива;
- некорректная длина кадра.

---

## 8) Почему в вашем проекте риск повышенный

По вашему логу сборки ранее:
- `data + bss` уже очень близко к 20 KB RAM,
- при этом есть FreeRTOS heap 14 KB + стеки задач.

Это значит, что проект работает близко к пределу и требует строгого контроля:
- `min_heap`,
- stack watermark всех задач,
- отсутствие крупных локальных буферов.

---

## 9) Как быстро снизить риск (пошагово)

## Шаг 1. Собрать реальные метрики

Погонять устройство под реальной нагрузкой (команды UART, FRAM операции, логирование) и записать:
- минимум `min_heap`;
- минимальные watermark по каждой задаче.

## Шаг 2. Подобрать стеки задач по факту

Если watermark задачи стабильно большой, можно уменьшить ее `stack_size`.
Если маленький - увеличить.

Цель: у каждой задачи оставить разумный запас, но не "переразмерять".

## Шаг 3. Сократить вывод `printf`

`printf` дорог по стеку и времени.
Полезно:
- укоротить строки;
- уменьшить частоту логов;
- избегать тяжелого форматирования в горячих участках.

## Шаг 4. Убрать большие локальные массивы

Локальные массивы бьют по стеку задачи.
Где возможно:
- использовать статические буферы;
- переиспользовать один буфер;
- держать буферы минимального необходимого размера.

## Шаг 5. Пересмотреть `configTOTAL_HEAP_SIZE`

Если heap стабильно избыточный, можно слегка уменьшить.
Если `min_heap` маленький - наоборот увеличить (но помня, что RAM общая и маленькая).

---

## 10) Важный момент про единицы измерения стеков

В проекте размер задачи задается в `osThreadAttr_t.stack_size`.
В CMSIS-RTOS V2 это задается в байтах, а внутри FreeRTOS преобразуется в слова.

А вот `uxTaskGetStackHighWaterMark()` возвращает слова.

Итог:
- при настройке `stack_size` думаем в байтах;
- при чтении watermark переводим `words -> bytes` умножением на 4.

---

## 11) Мини-шпаргалка для ежедневной проверки

После каждого заметного изменения прошивки:

1. Проверить, что устройство стабильно работает 10-30 минут.
2. Снять логи `Heap` и `Stk` под нагрузкой.
3. Оценить:
   - `min_heap`,
   - минимальный запас стека каждой задачи.
4. Если запас маленький - корректировать до появления комфортного резерва.

---

## 12) Как развивать диагностику дальше

Если захотите следующий уровень, можно добавить:

- тревогу (лог/LED) при `StkB free` ниже порога, например `< 64 B`;
- `vApplicationStackOverflowHook` для явной детекции переполнения стека;
- `vApplicationMallocFailedHook` для контроля ошибок heap;
- периодический отчет по очередям (`uxQueueMessagesWaiting`, max occupancy);
- отдельный "health task" с watchdog-пингом.

---

## 13) Краткий вывод

Для `STM32F103C8` память - главный ограничивающий ресурс.

Ваш текущий путь правильный:
- добавлен runtime-контроль heap/stack;
- задержки в задаче переведены на RTOS delay;
- можно принимать решения по стеку и heap на основе фактических метрик, а не "на глаз".

Самое главное правило:
- ориентироваться не на "средние" значения, а на худший случай (`min_heap` и минимальный watermark).

---

## 14) Подробно: как задаются stack/heap в проекте

Ниже - практическая "карта памяти" именно для STM32 + FreeRTOS.

### Базовые термины

- `RAM region` - вся доступная оперативная память МК (для `STM32F103C8` обычно `20 KB`).
- `MSP (Main Stack Pointer)` - стек старта и прерываний (это не стек задач FreeRTOS).
- `PSP (Process Stack Pointer)` - стек задач в режиме RTOS.
- `Task stack` - отдельный стек каждой RTOS-задачи.
- `FreeRTOS heap` - пул динамической памяти RTOS (`pvPortMalloc`), из него создаются очереди, таймеры, TCB и часто стеки задач.
- `watermark (high-water mark)` - минимальный исторический остаток свободного стека задачи.

### Где задается stack задач

В проекте (CMSIS-RTOS v2) стек задается в `osThreadAttr_t.stack_size` в байтах:

- `defaultTask_attributes.stack_size`
- `LedTask_attributes.stack_size`
- `Uart1Task_attributes.stack_size`

Важно:

- это выделенный размер под задачу;
- `uxTaskGetStackHighWaterMark()` возвращает остаток в `words`, поэтому в коде делается перевод в байты через `* sizeof(StackType_t)`.

### Где задается heap RTOS

Размер heap задается в `Core/Inc/FreeRTOSConfig.h`:

- `configTOTAL_HEAP_SIZE`

Именно это число вы видите как `Tot` в строке:

- `HeapB F:<free> Min:<min> Tot:<total>`

Если используется `heap_4.c` (обычно так и есть в CubeMX), тогда:

- `xPortGetFreeHeapSize()` показывает текущий свободный heap;
- `xPortGetMinimumEverFreeHeapSize()` показывает минимальный остаток за все время.

### Где задаются heap/stack линкера

В linker script (`*.ld`) обычно есть:

- `RAM (xrw) : ORIGIN = ..., LENGTH = ...`
- `_Min_Heap_Size`
- `_Min_Stack_Size`
- секции `.data`, `.bss`, `._user_heap_stack` (или аналогичные)

Это уже уровень C-runtime/newlib/startup, а не стеки задач FreeRTOS напрямую.

Итоговое ограничение всегда одно:

- `.data + .bss + C-runtime reserve + FreeRTOS heap + task stacks + запас MSP/IRQ <= RAM`.

---

## 15) Как контролировать память через линкер и команды

Надежный контроль делается в двух плоскостях:

1. статически (после сборки);
2. в рантайме (на устройстве под нагрузкой).

### 15.1 Статический контроль (build-time)

Минимальная команда:

```bash
arm-none-eabi-size build/primGPT.elf
```

Расшифровка:

- `text` - код и константы во Flash;
- `data` - инициализированные глобальные (занимают и Flash, и RAM);
- `bss` - неинициализированные глобальные (занимают RAM).

Быстрая оценка RAM в первом приближении:

- `RAM_used_static ~= data + bss`.

Для детального анализа нужен `map`-файл линкера.
Обычно добавляют флаг:

```bash
-Wl,-Map=primGPT.map,--cref
```

В `primGPT.map` полезно смотреть:

- общий итог по region `RAM`;
- размер секций `.data` и `.bss`;
- блок `._user_heap_stack` (или аналог);
- крупные глобальные массивы/символы.

Если статическое использование RAM уже высокое (например > 85-90%), это зона риска даже при "успешной сборке".

### 15.2 Рантайм-контроль (runtime)

Ваш текущий лог:

- `HeapB F:... Min:... Tot:...`
- `HeapU now:...% peak:...%`
- `StkB free D:... L:... U:...`
- `StkU % D:... L:... U:...`

Что важно:

- `HeapU peak` показывает худший случай по куче;
- `StkB free` показывает худший остаток стека каждой задачи;
- `StkB free = 0` - критичный сигнал;
- рост логирования и локальных буферов обычно сначала "съедает" stack задач.

---

## 16) Как связать map-файл и UART-логи в одну проверку

Рабочая последовательность после каждого изменения:

1. Сборка и проверка `size/map` (не выросли ли `.data/.bss`).
2. Прогон под реальной нагрузкой 10-30 минут.
3. Фиксация worst-case:
   - `HeapU peak`,
   - минимальные `StkB free` для всех задач.
4. Решение по результатам:
   - маленький `StkB free` -> увеличить стек конкретной задачи;
   - высокий `HeapU peak` -> пересмотреть `configTOTAL_HEAP_SIZE` и динамические объекты;
   - переполненный static RAM -> уменьшать глобальные буферы/логи.

---

## 17) Практические пороги для primGPT

- `StkB free < 128 B` - зона риска.
- `StkB free < 64 B` - критично, лучше увеличивать стек сразу.
- `StkB free = 0 B` - высокая вероятность stack overflow в худшем случае.
- `HeapU peak > 80-85%` - пора оптимизировать.
- `HeapU peak > 90%` - высокий риск malloc-fail при расширении функционала.

Для `STM32F103C8` лучше держать запас памяти, чем работать "впритык".

---

## 18) STM32CubeIDE: где смотреть память без командной строки

Ниже быстрый путь именно для STM32CubeIDE.

### 18.1 Где включить генерацию map-файла

1. Открыть `Project -> Properties`.
2. Перейти в `C/C++ Build -> Settings`.
3. Выбрать вкладку линкера (`MCU GCC Linker`).
4. В `Miscellaneous` добавить флаг:
   - `-Wl,-Map=${ProjName}.map,--cref`
5. Пересобрать проект (`Project -> Clean`, затем `Build`).

После сборки рядом с `elf` появится `*.map`.

### 18.2 Где смотреть RAM/Flash после Build

В `Console` после сборки обычно есть строка вида:

- `text data bss dec hex filename`

или summary от `size`.

Как читать:

- `Flash ~= text + data`;
- `RAM_static ~= data + bss`.

Это еще не весь runtime-RAM, потому что сюда не входят динамические пики RTOS так, как их видно в UART-диагностике (`HeapU/StkU`).

### 18.3 Где открыть map-файл в IDE

1. В `Project Explorer` найти `${ProjName}.map`.
2. Открыть как текст.
3. Поискать (`Ctrl+F`) ключевые секции:
   - `.data`
   - `.bss`
   - `._user_heap_stack` (или похожее имя)
   - `RAM` / `Memory Configuration`

На что смотреть:

- итоговое заполнение RAM region;
- большие глобальные массивы в `.bss`;
- неожиданный рост `.data`.

### 18.4 Мини-чеклист после каждого изменения

1. `Build` и проверить `text/data/bss` в `Console`.
2. Открыть `map` и убедиться, что нет резкого роста `.bss`.
3. Прошить и снять UART-диагностику:
   - `HeapU peak`
   - `StkB free` по всем задачам.
4. Если `StkB free` падает низко - увеличивать стек конкретной задачи.
5. Если `HeapU peak` высок - пересмотреть `configTOTAL_HEAP_SIZE` и динамические объекты RTOS.

Такой цикл дает полный контроль: линкер показывает "что заложили", а runtime-лог показывает "как реально живет память под нагрузкой".

---

## 19) Шаблон таблицы контроля по версиям прошивки

Ниже заготовка, которую удобно заполнять после каждого заметного изменения.

| Версия/коммит | Изменение | text (B) | data (B) | bss (B) | RAM static = data+bss (B) | HeapU now/peak (%) | StkB free D/L/U (B) | Риск | Примечание |
|---|---|---:|---:|---:|---:|---|---|---|---|
| v0.1 | После фикса stack/UART print | 32564 | 108 | 20276 | 20384 | 29/29 | 352/412/1744 | Watch | Runtime OK, но static RAM почти заполнена: 20384 из 20480 B (~99.5%) |
| v0.2 | Heap 10KB (MAX_PRIORITIES=56) | 32564 | 108 | 14644 | 14752 | 41/41 | 352/412/1744 | OK | RAM static: 14752 из 20480 B (~72%); большой запас восстановлен |
| v0.3 | Финальная валидация (map + runtime) | 32564 | 108 | 14644 | 14752 | 41/41 | 352/412/1744 | OK | Подтверждено на устройстве: `HeapB F:5960 Min:5960 Tot:10240`, стабильная работа |

### Как заполнять поля

- `text/data/bss` - из `arm-none-eabi-size` или из summary в `Console` CubeIDE.
- `RAM static` - сумма `data + bss`.
- `HeapU now/peak` - из UART-диагностики (`HeapU now:... peak:...`).
- `StkB free D/L/U` - минимальные остатки стеков из строки `StkB free`.
- `Риск` - короткая оценка (`OK` / `Watch` / `Critical`).

### Рекомендованный критерий риска

- `OK`:
  - `HeapU peak < 80%`
  - и `StkB free` у всех задач >= `128 B`.
- `Watch`:
  - `HeapU peak 80..90%`
  - или хотя бы у одной задачи `StkB free 64..127 B`.
- `Critical`:
  - `HeapU peak > 90%`
  - или `StkB free < 64 B`
  - или `StkB free = 0 B`.

---

## 20) Практический алгоритм на реальном кейсе (что мы сделали и чему это учит)

Ниже пример "как действовать правильно", когда проект на грани RAM и появляются зависания/ошибки сборки.

### Шаг 1. Зафиксировать симптомы

- В рантайме были признаки риска по стеку (`StkB free D:0`).
- По сборке: `data + bss` почти равно всей RAM (`20384 из 20480 B`).

Вывод: проблема не в одном месте, а в балансе stack/heap/static RAM.

### Шаг 2. Сначала стабилизировать runtime

Сделали безопасные изменения:

- увеличили `defaultTask` stack;
- защитили длину UART-передачи в `printf_uart3` (ограничение длины после `vsnprintf`);
- добавили более информативную диагностику `HeapB/HeapU/StkB/StkU`.

Результат:

- устройство перестало "виснуть";
- по логам появились реальные, интерпретируемые метрики.

### Шаг 3. Найти главный потребитель RAM по `map`

Проверили `Debug/primGPT.map` и увидели:

- большой `ucHeap` из `heap_4` (это `configTOTAL_HEAP_SIZE`);
- заметный вклад служебных структур RTOS и linker reserve.

Вывод: главный рычаг оптимизации - размер heap и конфиг RTOS, а не мелкие локальные переменные.

### Шаг 4. Делать оптимизацию по одному параметру

Пробный шаг:

- уменьшили `configTOTAL_HEAP_SIZE` (это корректный путь);
- попытались уменьшить `configMAX_PRIORITIES`.

Получили ошибку сборки:

- `freertos_os2.h: error: configMAX_PRIORITIES must equal 56`.

Правильная реакция:

- откатить только несовместимый параметр (`configMAX_PRIORITIES` обратно в `56`);
- оставить рабочие изменения (например, уменьшенный heap), которые не ломают API-обертку CMSIS-RTOS V2.

### Шаг 5. Проверка после каждого изменения

После каждого шага проверяем два контура:

1. build-time: `size/map` (стало ли меньше `data+bss`);
2. runtime: `HeapU peak` и `StkB free` под нагрузкой.

Только так изменения считаются "успешными": когда и сборка, и рантайм стабильны.

### Что в итоге достигли

- нашли и устранили реальную причину зависаний (стек + небезопасная передача строки);
- сделали диагностику памяти понятной в процентах и байтах;
- получили воспроизводимый процесс анализа через `size + map + UART-метрики`;
- выявили ограничение CMSIS-RTOS V2: `configMAX_PRIORITIES` в этой конфигурации менять нельзя.
- финально подтвердили рабочий профиль памяти:
  - static RAM: `14752/20480` (~72%);
  - heap runtime: `HeapU peak = 41%` (`5960 B` свободно из `10240 B`);
  - stack runtime: `StkB free D/L/U = 352/412/1744 B`.

### Как грамотно действовать в похожих ситуациях

- не менять сразу много параметров "пакетом";
- всегда фиксировать метрики до/после;
- при ошибке сборки откатывать только конфликтный параметр;
- сначала добиваться стабильности, потом оптимизировать память;
- решения принимать по worst-case (`HeapU peak`, минимальный `StkB free`), а не по "средним" значениям.

