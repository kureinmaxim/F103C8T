# Урок 3: Прерывания — как байт доходит от пина до логики

## 1) Исторически почему ISR + очередь

- На ранних этапах часто делают polling (в цикле опрашивают UART).
- Это тратит CPU и плохо масштабируется.
- Правильный RTOS-подход: событие в ISR -> данные в очередь -> обработка в задаче.

## 2) Реальный поток в проекте

1. Байт приходит на `PA10` (`USART1_RX`).
2. Срабатывает `USART1_IRQHandler` (`Core/Src/stm32f1xx_it.c`).
3. HAL вызывает `HAL_UART_RxCpltCallback` (`Core/Src/uart.c`).
4. ISR кладет байт в `uartQueue` через `xQueueSendFromISR`.
5. `Uart1Task` читает очередь и собирает кадр.

## 3) Почему это важно

- ISR остается коротким.
- Тяжелая логика (CRC, switch по командам, FRAM) выполняется в task context.
- Снижается риск "подвисаний" из-за долгих обработчиков прерываний.

## 4) Практические правила

- В ISR использовать только `...FromISR` API FreeRTOS.
- Не делать `HAL_Delay` в ISR.
- Всегда перезапускать `HAL_UART_Receive_IT` для следующего байта.

## 5) Что проверить на железе

- При активном трафике UART не должно быть потери байтов.
- Очередь не должна переполняться (можно добавить счетчик drop/overflow).

