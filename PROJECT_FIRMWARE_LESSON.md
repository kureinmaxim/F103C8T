# primGPT (STM32F103 + FreeRTOS): алгоритм работы, архитектура и сигналы

Этот документ оформлен как практический урок по текущей прошивке проекта `primGPT`.
Цель: дать целостную картину, как система запускается, какие технологии используются, как идут сигналы по пинам, как работает FreeRTOS в этом проекте, и куда можно развивать код дальше.

---

## 1) Что это за проект

`primGPT` - встраиваемая прошивка для `STM32F103C8Tx` (Cortex-M3), написанная на C, собранная в STM32CubeIDE, с RTOS-слоем на `FreeRTOS v10.0.1` (через CMSIS-RTOS v2).

Фактически это RTOS-система с тремя задачами:
- обработка команд по `UART1` с проверкой `CRC16-MODBUS`;
- периодическая индикация по GPIO;
- сервисная печать "тиков" по `UART3`.

Также подключена внешняя FRAM-память по `SPI1` с программным `CS` на `PA4`.

---

## 2) Технологический стек и ключевые зависимости

- MCU: `STM32F103C8T6`, частота ядра `72 MHz` (HSE 8 MHz -> PLL x9).
- HAL: `STM32 HAL` (CubeMX/CubeIDE generated + user code blocks).
- RTOS: `FreeRTOS v10.0.1`, CMSIS-RTOS V2 API для тредов.
- Очереди: используется нативный API FreeRTOS (`xQueueCreate`, `xQueueSendFromISR`, `xQueueReceive`).
- Интерфейсы:
  - `USART1` 38400 (командный канал, RX по прерыванию);
  - `USART3` 115200 (лог/отладка);
  - `SPI1` 4.5 Mbit/s (FRAM).
- Контроль целостности: `CRC16` с полиномом `0xA001`.

---

## 2.1) Термины простыми словами: HAL и очереди FreeRTOS

### Что такое HAL

`HAL` (`Hardware Abstraction Layer`) - это библиотека ST, которая скрывает прямую работу с регистрами микроконтроллера за удобными функциями.

Примеры из проекта:
- `HAL_UART_Init(...)` - инициализация UART;
- `HAL_GPIO_TogglePin(...)` - переключение GPIO;
- `HAL_SPI_Transmit(...)` - передача данных по SPI;
- `HAL_UART_Receive_IT(...)` - запуск приема UART по прерыванию.

Идея простая: вместо ручной работы с битами регистров вы вызываете типовые функции HAL.

### Что такое `xQueueCreate`

`xQueueCreate(length, itemSize)` - создает очередь FreeRTOS.

В вашем проекте:
- `uartQueue = xQueueCreate(40, sizeof(char));`
- это очередь на 40 элементов;
- каждый элемент - 1 байт.

Очередь нужна, чтобы безопасно передавать данные от ISR к задаче.

### Что такое `xQueueSendFromISR`

`xQueueSendFromISR(...)` - положить элемент в очередь из обработчика прерывания.

В вашем проекте:
- USART1 принял байт;
- в `HAL_UART_RxCpltCallback()` этот байт отправляется в `uartQueue`.

Важно: используется именно версия `FromISR`, потому что обычные API вызовы в прерывании использовать нельзя.

### Что такое `xQueueReceive`

`xQueueReceive(...)` - получить элемент из очереди в задаче.

В вашем проекте:
- `Uart1Task` получает байты из `uartQueue`;
- собирает команду;
- по таймауту кадра проверяет CRC и выполняет команду.

### Мини-схема именно вашего потока

```text
PA10 (USART1_RX) -> IRQ USART1
-> HAL_UART_RxCpltCallback()
-> xQueueSendFromISR(uartQueue, byte)
-> Uart1Task: xQueueReceive(uartQueue, ...)
-> разбор команды + CRC + действие
-> ответ по PA9 (USART1_TX)
```

---

## 3) Структура проекта (по смыслу)

- `Core/Src/main.c` - запуск MCU, инициализация, создание задач, главный алгоритм.
- `Core/Src/uart.c` - UART-утилиты, ISR callback приема байта, отправка байта в очередь RTOS.
- `Core/Src/fram.c` - SPI-драйвер FRAM (WREN/WRDI/READ/WRITE).
- `Core/Src/crc16.c` - CRC16-MODBUS и функции проверки/добавления CRC.
- `Core/Inc/DataFile.h` - константы протокола и буфера (`UART_TIMEOUT_MS`, `UART_BUF_SIZE`, ID).
- `Core/Inc/FreeRTOSConfig.h` - конфиг RTOS (tick, heap, priorities, syscall interrupt level).
- `primGPT.ioc` - источник конфигурации CubeMX (пины, clock tree, периферия, RTOS).

---

## 4) Аппаратная карта пинов и направления сигналов

### GPIO/индикация

- `PC13` - GPIO output (LED/индикатор состояния, переключается задачами и командой UART).
- `PC15` - GPIO output (маркер активности `Uart1Task`, toggling).

### UART

- `PA9`  -> `USART1_TX` (выход командных ответов).
- `PA10` <- `USART1_RX` (вход команд от внешнего устройства).
- `PB10` -> `USART3_TX` (отладочный вывод).
- `PB11` <- `USART3_RX` (сконфигурирован в MSP, в текущем приложении практически не используется).

### SPI1 -> FRAM

- `PA5`  -> `SPI1_SCK` (тактовая линия).
- `PA7`  -> `SPI1_MOSI` (данные к FRAM).
- `PA6`  <- `SPI1_MISO` (данные от FRAM).
- `PA4`  -> `FRAM_CS` (software chip select, обычный GPIO).

### Тактирование и отладка

- `PD0/PD1` - HSE вход/выход кварца.
- `PA13/PA14` - SWD (`SWDIO`, `SWCLK`) для прошивки/отладки.

---

## 5) Наглядный поток сигналов (кто, куда и зачем)

## 5.1 UART1: прием команд

```text
Внешний мастер
   |
   |  (UART, 38400)
   v
PA10 / USART1_RX
   |
   | IRQ USART1 -> HAL_UART_IRQHandler()
   v
HAL_UART_RxCpltCallback()
   |
   | xQueueSendFromISR(uartQueue, byte)
   v
FreeRTOS queue (40 bytes)
   |
   | xQueueReceive() в Uart1Task
   v
Буфер команды + таймаут кадра (200 ms) + CRC16 check
   |
   +--> команда 0x70: управление PC13
   |
   +--> команда 0x02: запись/чтение FRAM по SPI1
   |
   v
Ответ (ID + status + CRC16) -> PA9 / USART1_TX
```

## 5.2 SPI1: обмен с FRAM

```text
Uart1Task
   |
   | fram_write()/fram_read()
   v
PA4 (CS low)
PA5 (SCK)
PA7 (MOSI) ---> FRAM
PA6 (MISO) <--- FRAM
PA4 (CS high)
```

## 5.3 UART3: сервисный лог

```text
StartDefaultTask / log_printf()
   |
   v
PB10 / USART3_TX -> внешний UART-адаптер/логгер
```

---

## 6) Алгоритм функционирования прошивки (шаг за шагом)

Ниже - реальный порядок выполнения после reset:

1. `main()`:
   - считывает и очищает reset flags (`RCC->CSR`);
   - `HAL_Init()`;
   - `SystemClock_Config()` -> SYSCLK = 72 MHz;
   - `MX_GPIO_Init()`, `MX_USART1_UART_Init()`, `MX_USART3_UART_Init()`, `MX_SPI1_Init()`.

2. Инициализация прикладного уровня:
   - стартует прерывание приема UART1: `HAL_UART_Receive_IT(..., 1 byte)`;
   - инициализируется FRAM: `fram_cfg_setup()`, `fram_init()`.

3. Инициализация RTOS:
   - `osKernelInitialize()`;
   - создается очередь `uartQueue` на 40 элементов по 1 байту;
   - создаются потоки:
     - `defaultTask` (Normal, stack 512),
     - `LedTask` (Normal, stack 512),
     - `Uart1Task` (AboveNormal, stack 2048).

4. `osKernelStart()`:
   - управление полностью переходит планировщику FreeRTOS;
   - дальнейшая работа идет через task scheduling и ISR.

5. Во время работы:
   - ISR UART1 складывает каждый принятый байт в очередь;
   - `Uart1Task` собирает пакет, ждет паузу > 200 ms, проверяет CRC;
   - выполняет команду, формирует и отправляет ответ;
   - `LedTask` и `defaultTask` выполняют периодические функции.

---

## 7) Логика командного протокола (UART1 + CRC16)

### Формат кадра

- Полезная команда + 2 байта CRC16 (LSB first).
- В проекте проверка через `process_crc(..., checkFlag=true)`:
  - если результат `crc16(frame_with_crc) == 0`, кадр валиден.

### Тайминг кадра

- Принцип "межбайтный таймаут":
  - пока байты приходят, они накапливаются;
  - если после последнего байта прошло > `UART_TIMEOUT_MS` (200 ms), кадр считается завершенным.

### Поддерживаемые команды (на текущий момент)

- `0x70`:
  - `command[1] == 0` -> `PC13 = SET`;
  - `command[1] == 1` -> `PC13 = RESET`.

- `0x02`:
  - тест FRAM: запись строки `"KUREIN"` в адрес `0x0150`, затем чтение.

### Ответ

- Ответный кадр строится как:
  - 2 байта данных: `[ID_BU, 0x00]`,
  - + CRC16 для этих 2 байт,
  - итого 4 байта в UART1 TX.

---

## 8) FreeRTOS в проекте: мини-введение + как это реально работает здесь

## 8.1 Что такое FreeRTOS в данном контексте

FreeRTOS дает:
- многозадачность (несколько независимых задач);
- планирование по приоритетам;
- межзадачное взаимодействие (очереди/семафоры/мьютексы);
- безопасное взаимодействие ISR с задачами (`FromISR` API).

В проекте реализован типичный шаблон "IRQ producer -> queue -> worker task":
- ISR максимально короткий: принял байт, положил в очередь, вышел;
- основная обработка (CRC, разбор команд, FRAM-операции) выполняется в задаче.

Это правильно для embedded-систем: уменьшается время нахождения в прерывании и улучшается предсказуемость.

## 8.2 Текущая RTOS-конфигурация

- `configTICK_RATE_HZ = 1000` (1 ms tick).
- `configTOTAL_HEAP_SIZE = 14 KB`.
- `configMAX_PRIORITIES = 56`.
- `configUSE_PREEMPTION = 1` (вытесняющее планирование).
- ISR `USART1_IRQn` настроен с приоритетом `5`, что совместимо с `configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY = 5` для вызовов `xQueueSendFromISR`.

## 8.3 Что важно понимать про API

- Потоки создаются через CMSIS-RTOS (`osThreadNew`).
- Очередь создается через native FreeRTOS (`xQueueCreate`) - это допустимый гибрид, но лучше в проекте держать единый стиль API для удобства поддержки.

---

## 9) Ограничения и риски текущей реализации

## 9.1 Ограничения платформы

- RAM всего ~20 KB, из них RTOS heap уже 14 KB -> запас под стек задач и буферы ограничен.
- Flash 64 KB -> нужен контроль роста кода и логирования.

## 9.2 Ограничения/нюансы кода

- `StartDefaultTask` использует `HAL_Delay()` вместо `vTaskDelay()/osDelay()`.
  - В RTOS-задачах желательно использовать именно RTOS delay, чтобы не нарушать модель планирования.
- В `uart.c` буфер `log_printf`/`printf_uart3` = 32 байта.
  - Длинные строки будут обрезаться.
- `calculate_crc_for_2_bytes()` возвращает указатель на статический буфер.
  - Функция не реентерабельна (нельзя безопасно использовать одновременно из нескольких задач/ISR).
- В `Uart1Task` есть `HAL_Delay(1000)` в ветке FRAM-команды.
  - Это блокирует задачу надолго; лучше заменить на RTOS delay или неблокирующую state machine.
- Для бинарного протокола межбайтный таймаут 200 ms может быть слишком большим для высоких скоростей обмена.

---

## 10) Как развивать проект дальше (практический roadmap)

## Шаг 1. Стабилизировать RTOS-поведение

- Заменить `HAL_Delay()` внутри задач на `vTaskDelay()`/`osDelay()`.
- Добавить stack watermark мониторинг:
  - `uxTaskGetStackHighWaterMark()` для каждой задачи.

## Шаг 2. Усилить протокол UART1

- Ввести явный формат кадра:
  - `SOF | LEN | CMD | PAYLOAD | CRC16`.
- Добавить NACK-коды ошибок:
  - bad CRC, unknown CMD, bad length, timeout.
- Сделать таблицу обработчиков команд (dispatch table) вместо большого `switch`.

## Шаг 3. Улучшить поток данных

- Перейти с "байт в очередь" на:
  - stream buffer/message buffer,
  - или DMA + ring buffer + parser task.
- Добавить защиту от overflow и статистику потерь.

## Шаг 4. FRAM как подсистема хранения

- Выделить слой "логических записей" поверх raw адресов:
  - заголовок записи, версия, длина, CRC.
- Реализовать ring-log в FRAM для событий и телеметрии.

## Шаг 5. Инфраструктура качества

- Юнит-тесты для `crc16` и парсера протокола (на host-машине).
- Интеграционный smoke-тест по UART (скрипт на Python).
- Карта памяти и контроль свободного heap/stack в runtime.

---

## 11) Короткое "как это объяснить новичку" (мини-урок)

Представьте систему как конвейер:

1. Железо принимает байт на `PA10`.
2. Прерывание быстро передает байт в очередь.
3. Задача `Uart1Task` в фоне собирает и проверяет команду.
4. Если команда про GPIO - переключает `PC13`.
5. Если команда про память - общается с FRAM через `PA5/PA6/PA7 + PA4`.
6. Ответ уходит обратно по `PA9`.
7. Параллельно другие задачи делают индикацию и логи.

Именно в этом и смысл RTOS: несколько независимых процессов работают "одновременно" и не мешают друг другу, если грамотно разделены ISR и task-level логика.

---

## 12) Рекомендации по правилам редактирования CubeMX-проекта

- В файлах, генерируемых CubeMX (`main.c`, `stm32f1xx_hal_msp.c`, `stm32f1xx_it.c`), менять код только внутри блоков:
  - `USER CODE BEGIN ...`
  - `USER CODE END ...`
- Иначе изменения могут быть потеряны при регенерации из `.ioc`.

---

## 13) Итог

Текущая архитектура проекта уже использует правильный базовый паттерн для RTOS-устройств:
- ISR короткий,
- основная обработка в задачах,
- очередь как граница между hardware event и бизнес-логикой.

Это хорошая отправная точка для расширения протокола, повышения надежности и масштабирования функциональности (новые команды, телеметрия, журналирование в FRAM, watchdog, self-test, OTA/bootloader-этапы в будущем).

